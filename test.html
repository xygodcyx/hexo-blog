<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>像素点丝滑 Idle 动画（Canvas）</title>
    <style>
        :root {
            --bg: #0b0b0f;
            --ui: #eee
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--ui);
            font-family: Inter, system-ui, Segoe UI, Roboto, "Helvetica Neue", Arial;
        }

        .wrap {
            display: flex;
            height: 100%;
            gap: 12px
        }

        .left {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative
        }

        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%
        }

        .ui {
            width: 340px;
            padding: 18px;
            background: rgba(255, 255, 255, 0.04);
            backdrop-filter: blur(6px);
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.6);
        }

        .row {
            margin-bottom: 12px
        }

        label {
            display: block;
            font-size: 13px;
            opacity: .9;
            margin-bottom: 6px
        }

        input[type=range] {
            width: 100%
        }

        input[type=file] {
            color: var(--ui)
        }

        .small {
            font-size: 13px;
            color: #bfbfbf
        }

        .btn {
            display: inline-block;
            padding: 8px 10px;
            border-radius: 6px;
            background: linear-gradient(180deg, #ff6b6b, #ff3b3b);
            color: #fff;
            text-decoration: none;
            cursor: pointer;
            border: none
        }

        footer {
            font-size: 12px;
            color: #9a9a9a;
            margin-top: 8px
        }

        @media(max-width:900px) {
            .wrap {
                flex-direction: column
            }

            .ui {
                width: 100%
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div class="left">
            <canvas id="c"></canvas>
        </div>

        <div class="ui" id="ui">
            <div class="row">
                <label>选择图片（或拖放到页面任意处）</label>
                <input id="file" type="file" accept="image/*">
            </div>

            <div class="row">
                <label>点密度（分辨率）: <span id="densText">18</span></label>
                <input id="density" type="range" min="6" max="36" value="18">
                <div class="small">数值越小像素越大（点更少），数值越大点越细（更接近原图）</div>
            </div>

            <div class="row">
                <label>点大小倍数: <span id="sizeText">1.0</span></label>
                <input id="size" type="range" min="0.4" max="2.2" step="0.05" value="1">
            </div>

            <div class="row">
                <label>摆动幅度（像素）: <span id="ampText">6</span></label>
                <input id="amplitude" type="range" min="0" max="30" value="6">
            </div>

            <div class="row">
                <label>摆动速度: <span id="speedText">1.0</span></label>
                <input id="speed" type="range" min="0.1" max="3" step="0.05" value="1">
            </div>

            <div class="row">
                <button id="resetBtn" class="btn">重置为示例图</button>
                <span style="margin-left:8px" class="small">移动端会自动停用效果以保证性能</span>
            </div>

            <footer>提示：可拖动图片到窗口中。想更丝滑就调高 <b>摆动速度</b> 或降低 <b>密度</b>。</footer>
        </div>
    </div>

    <script>
        /*
          核心思路：
          - 读取图片并绘制到离屏 canvas，再按 grid (density) 采样颜色
          - 为每个像素点创建 particle 存储初始位置、颜色、phase、speed、amplitude
          - 每帧计算目标位置 = origin + offset（offset 用 sin(time*speed + phase) * amp * brightnessFactor）
          - 使用 lerp 将 particle 当前位置平滑过渡到目标位置 -> 丝滑效果
          - 移动端自动禁用（检测 touch），减少资源使用
        */

        (() => {
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d', { alpha: false });

            // UI元素
            const fileInput = document.getElementById('file');
            const densityEl = document.getElementById('density');
            const densityText = document.getElementById('densText');
            const sizeEl = document.getElementById('size');
            const sizeText = document.getElementById('sizeText');
            const ampEl = document.getElementById('amplitude');
            const ampText = document.getElementById('ampText');
            const speedEl = document.getElementById('speed');
            const speedText = document.getElementById('speedText');
            const resetBtn = document.getElementById('resetBtn');

            let WIDTH = 1000, HEIGHT = 700;
            let deviceIsTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 1;
            if (deviceIsTouch) {
                // 移动端：隐藏 UI? 这里只禁用动画但仍允许显示静态采样
                densityEl.max = 28; // 降低上限避免太多点
            }

            // particles array
            let particles = [];
            let img = new Image();
            let off = document.createElement('canvas');
            let offCtx = off.getContext('2d');

            // 参数
            function getParams() {
                return {
                    density: parseInt(densityEl.value, 10),
                    sizeMul: parseFloat(sizeEl.value),
                    amplitude: parseFloat(ampEl.value),
                    speedMul: parseFloat(speedEl.value)
                };
            }

            // 监听 UI 展示数值
            function updateUI() {
                densityText.textContent = densityEl.value;
                sizeText.textContent = parseFloat(sizeEl.value).toFixed(2);
                ampText.textContent = ampEl.value;
                speedText.textContent = parseFloat(speedEl.value).toFixed(2);
            }
            densityEl.addEventListener('input', () => { updateUI(); rebuildParticles(); });
            sizeEl.addEventListener('input', updateUI);
            ampEl.addEventListener('input', updateUI);
            speedEl.addEventListener('input', updateUI);

            // 加载示例图片（内嵌小图，避免跨域）
            const exampleData = "data:image/svg+xml;utf8," + encodeURIComponent(`
    <svg xmlns="http://www.w3.org/2000/svg" width="400" height="280">
      <rect width="100%" height="100%" fill="#0b1220"/>
      <g transform="translate(40,40) scale(0.9)">
        <circle cx="120" cy="72" r="60" fill="#ff7a7a"/>
        <rect x="90" y="140" width="120" height="60" rx="12" fill="#ffd86e"/>
        <path d="M40 30 L200 30 L120 170 Z" fill="#7ad0ff" opacity="0.95"/>
      </g>
    </svg>
  `);

            // resize canvas
            function fitCanvas() {
                const container = document.querySelector('.left');
                const rect = container.getBoundingClientRect();
                WIDTH = Math.max(320, Math.floor(rect.width));
                HEIGHT = Math.max(240, Math.floor(rect.height));
                canvas.width = WIDTH;
                canvas.height = HEIGHT;
            }
            window.addEventListener('resize', () => { fitCanvas(); rebuildParticles(); });

            // helper: linear interpolation
            function lerp(a, b, t) { return a + (b - a) * t; }

            // build particles from current img & params
            function rebuildParticles() {
                if (!img || !img.width) return;
                fitCanvas();

                const params = getParams();
                const grid = params.density;

                // draw image to offscreen in target size (fit inside canvas)
                const mw = canvas.width, mh = canvas.height;
                const iw = img.width, ih = img.height;
                // fit-cover style: scale to fit inside with aspect preserved and center
                const scale = Math.min(mw / iw, mh / ih);
                const drawW = Math.floor(iw * scale);
                const drawH = Math.floor(ih * scale);
                off.width = drawW;
                off.height = drawH;
                offCtx.clearRect(0, 0, off.width, off.height);
                offCtx.drawImage(img, 0, 0, drawW, drawH);

                const imgData = offCtx.getImageData(0, 0, drawW, drawH).data;

                particles = [];
                // sample grid from off canvas
                for (let y = 0; y < drawH; y += grid) {
                    for (let x = 0; x < drawW; x += grid) {
                        const idx = ((y * drawW) + x) * 4;
                        const r = imgData[idx], g = imgData[idx + 1], b = imgData[idx + 2], a = imgData[idx + 3];
                        if (a === 0) continue; // fully transparent skip

                        // brightness factor [0..1]
                        const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                        // place particle centered relative to canvas
                        const cx = (canvas.width - drawW) * 0.5 + x + grid / 2;
                        const cy = (canvas.height - drawH) * 0.5 + y + grid / 2;

                        particles.push({
                            ox: cx, oy: cy,      // origin (where it should rest)
                            x: cx + (Math.random() - 0.5) * 6, y: cy + (Math.random() - 0.5) * 6, // current pos
                            color: `rgba(${r},${g},${b},${a / 255})`,
                            brightness: brightness,
                            phase: Math.random() * Math.PI * 2,
                            speed: 0.4 + Math.random() * 1.4,
                            amp: 0.6 + Math.random() * 1.4,
                            sizeBase: Math.max(1, grid * 0.65)
                        });
                    }
                }
            }

            // animate
            let t0 = performance.now();
            function render(now) {
                const dt = (now - t0) / 1000;
                const time = now / 1000;
                t0 = now;

                // clear background (solid for performance)
                ctx.fillStyle = '#0b0b0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (particles.length === 0) {
                    requestAnimationFrame(render);
                    return;
                }

                const params = getParams();
                const amplitude = params.amplitude;
                const speedMul = params.speedMul;
                const sizeMul = params.sizeMul;

                // draw particles
                // draw order: from back to front (smaller brightness first) to have depth feel
                // we sort once per frame (cheap enough), but could pre-sort
                particles.sort((a, b) => a.brightness - b.brightness);

                // high performance draw: use path for circles or rectangles
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];

                    // compute per-pixel offset target using smooth sin waves
                    // amplitude scales by brightness so darker parts jiggle less
                    const localAmp = p.amp * amplitude * (0.25 + p.brightness * 0.9);
                    const s = Math.sin(time * p.speed * speedMul + p.phase);
                    const c = Math.cos(time * p.speed * speedMul + p.phase * 1.3);

                    const tx = p.ox + s * localAmp;
                    const ty = p.oy + c * localAmp * 0.6;

                    // lerp current pos => target pos for smoothness
                    const lerpT = 0.12; // smoothing factor (0..1), 小值更丝滑
                    p.x = lerp(p.x, tx, lerpT);
                    p.y = lerp(p.y, ty, lerpT);

                    // size varies subtly with brightness and index
                    const size = Math.max(0.6, p.sizeBase * sizeMul * (0.6 + p.brightness * 0.9));

                    // draw circle
                    ctx.beginPath();
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = 0.95;
                    ctx.arc(p.x, p.y, size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.globalAlpha = 1;
                requestAnimationFrame(render);
            }

            // file load handler
            fileInput.addEventListener('change', (e) => {
                const f = e.target.files && e.target.files[0];
                if (!f) return;
                const url = URL.createObjectURL(f);
                loadImage(url);
            });

            // drag+drop support
            window.addEventListener('dragover', e => { e.preventDefault(); });
            window.addEventListener('drop', e => {
                e.preventDefault();
                const f = e.dataTransfer.files && e.dataTransfer.files[0];
                if (f) {
                    const url = URL.createObjectURL(f);
                    loadImage(url);
                }
            });

            // load image helper
            function loadImage(src) {
                const i = new Image();
                i.crossOrigin = "anonymous";
                i.onload = () => {
                    img = i;
                    rebuildParticles();
                };
                i.onerror = () => {
                    console.warn('图片加载失败：', src);
                };
                i.src = src;
            }

            // reset to example
            resetBtn.addEventListener('click', () => loadImage(exampleData));

            // init
            function init() {
                fitCanvas();
                updateUI();
                loadImage(exampleData);
                requestAnimationFrame(render);
            }
            init();

        })();
    </script>
</body>

</html>